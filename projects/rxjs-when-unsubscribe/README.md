# RxJs. Когда нужно отписываться (unsubscribe)

Наиболее частые вопрос, который возникает у разработчика Angular — **когда всё-таки нужно отписываться, а когда нет и зачем это нужно.**  

В небольших проектах можно не отписываться и не заметить, каких либо проблем. Но с ростом проекта можно будет обнаружить замедление работы приложения – долгий отклик, подтормаживание и странные трудноуловимые баги. 

Это всё связано с тем, что весь код после уничтожения компонентов, например, при навигации, будет накапливаться и продолжать выполняться в фоне до тех пор пока не закончится память в браузере.
  
## Когда нужно отписываться

Для начала отметим, что в Angular существуют два вида `Observable` — **финитные и инфинитные,** одни производят конечное, другие, соответственно, бесконечное число значений.

Примеры финитных – это `Http Observable`, таймеры, а инфинитные, – это  слушатели/наблюдатели (listeners) DOM событий, интервалы. 

В сети можно найти множество статей, где пишут, что от финитных можно не отписываться, но это не так. Например, если выполняется долгий `Http` запрос, но компонент за это время был уже уничтожен, то запрос всё равно выполнится, а соответственно и обрабатывающий его код в подписке. 

Кроме того, если в подписке есть обращение к компоненту, то после его уничтожения – всё равно в подписке сохранится ссылка на компонент, что может стать потенциальной утечкой памяти.

С инфинитными всё сложнее, если от них не отписаться, то код продолжит выполняться на отслеживаемый поток событий, даже после уничтожения компонента.  

### Операторы take, first, takeWhile

Операторы условия, такие как `take, first, takeWhile` и т. д., приводящие инфинитные запросы к финитным, не панацея, они на самом деле не делают отписку, а работают также, как если бы не отписались от Http. Кроме того, условие может вообще не выполниться и работа подписки продолжит накапливаться в памяти. 

Например, если вывести в консоль первые десять записей `take(10)` от интервала и  уничтожить компонент, то мы сможем наблюдать продолжение выполнения кода. В данном случае не всё так страшно, код прекратит выполняться, но отписки не произойдёт.

## Как правильно отписываться

Самым правильным способом является не делать подписку в компоненте вообще, а использовать для этого `AsyncPipe` в шаблоне.  

В случае, если это нельзя сделать, то можно использовать метод `unsubscribe()` или оператор фильтра `takeUntil`.

В сети также можно найти множество разных способов упрощения отписки, такие как группировка unsubscribe() в массив или использование обёртки в виде специального декоратора `AutoUnsubscribe` (https://github.com/NetanelBasal/ngx-auto-unsubscribe). 

Рассмотрим наиболее правильные и популярные методы.

### AsyncPipe

Его нужно использовать во всех возможных случаях. Так как он не создаёт подписку в компоненте, поэтому отписываться и не нужно. 

```
<div *ngFor="todos$ | async"></div>
<app [data]="todos$ | async"></app>
{{ todos$ | async }}
```

### Unsubscribe

Это стандартный метод для отписки, но у него есть недостаток в том, что при росте проекта, таких отписок может быть много и могут возникнуть сложности с поддержкой.

Отписку нужно делать в методе ngOnDestroy жизненно цикла компонента.

```
  todos: Todo[];
  click$: Subscription;
  todos$: Subscription;

  constructor(private element: ElementRef, private http: HttpClient) {}

  ngOnInit() {
    this.todos$ = this.http.get(...)
      .subscribe(todos => this.todos = todos);  
      
    this.click$ = fromEvent(this.element.nativeElement, "click")
      .subscribe(...);    
  }

  ngOnDestroy(): void {
    this.click$.unsubscribe();
    this.todos$.unsubscribe();
  }
}
```

### Использование takeUntil

Это один из самых популярных методов для отписки, решающий проблему написания множества отписок у `unsubscribe()`.

Оператор фильтра `takeUntil` работает следующим образом. Он подписывается на источник данных и в него передается Observable, который сообщает, когда сделать отписку.
В качестве Observable будем использовать `Subject`, который в методе `ngOnDestroy`, вызываемым при уничтожении компонента, мы будем его завершать.

```
  private unsubscribe$ = new Subject<void>();
      
  todos: Todo[];

  constructor(private element: ElementRef, private http: HttpClient) {}

  ngOnInit() {
    this.http.get(...)
      .pipe(takeUntil(this.unsubscribe$))
      .subscribe(todos => this.todos = todos);  
      
    fromEvent(this.element.nativeElement, "click")
      .pipe(takeUntil(this.unsubscribe$))
      .subscribe(...);
    }      
  }

  ngOnDestroy(): void {
    this.unsubscribe$.next();
    this.unsubscribe$.complete();
  }
}
```
